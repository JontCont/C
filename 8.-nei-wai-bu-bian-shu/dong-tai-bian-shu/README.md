# 動/靜態變數、暫存器變數

## 動態變數

程式執行時，配置記憶體的變數，稱謂動態變數。

## 靜態變數

除範圍之外，變數還有存活期，在這個期間變數可以保持它們的值。在應用程式的存活期內，模組層次變數和公用變數的值會一直保持著。但是，對於用宣告的區域變數，只有當宣告它們的程序在執行時，這些區域變數才存在。

通常，當一個程序執行完畢，所含區域變數的值就會消失，而且變數所佔據的記憶體也會被釋放。當下一次執行該程序時，它的所有區域變數將重新初始化。靜態變數分為兩種:

* 內部靜態變數
* 外部靜態變數

### 內部靜態變數

選告在{ } 區塊內，且宣告時候在資料型態前有static字樣的變數，稱為內部靜態變數。

```c
#include <stdio.h>
#include <stdlib.h>
void fun1();
int times = 1; /* 全域變數 */

int main(int argc, char *argv[])
{
    for (times = 1; times <= 5; times++) /* 呼叫 fun1()函式 5 次 */
    {
        fun1();
    }
    printf("\n");
    system("PAUSE");
    return 0;
}
void fun1()
{
    int a_var = 10;         /* 自動變數 */
    static int l_stat = 10; /* 局部靜態變數 */
    printf(" \n %d. a_var1=%d l_stat= %d \n",times,a_var++,l_stat++); 
}
```

### 外部靜態變數

選告在{ } **區塊外**，且宣告時候在資料型態前有static字樣的變數，稱為內部靜態變數。持久性和有效範圍和全域變數一樣。

外部靜態變數的生命週期是由該變數宣告開始，便在記憶體內佔用 一個位置來存放該變數的內容，一直到程式結束執行為止，其有效範圍 整個程式內均有效。

譬如下例假設左右兩個彼此是獨 立的兩個檔案，將兩個檔案編譯在一起時，times 是屬於全域變數，它允 許 file1.c 檔的 main\(\)、fun1\(\)和 file2.c 檔的 fun2\(\)、fun3\(\)共同參用。至 於 g\_stat 為全域靜態變數，它僅限 file1.c 檔的 main\(\)、fun1\(\)共同參用。

## 暫存器變數

指示變數需存放在機器的暫存器中，適用於特別需要高速存取的變數

* 以關鍵字**register**修飾的變數
* 編譯器通常會對暫存器的使用做最佳化，編譯器有權不理會這個修飾詞，所以通常不需指定。有些編譯器沒有操作暫存器的權限，或受限於電腦暫存器的數量
* 暫存器沒有位址，所以不能使用&運算子來取得變數的位址， 只有區域變數和函式的引數才可宣告為暫存器變數

```c
register int num = 0 ;
void function(register int num)
{     
}
```

## Volatile變數 <a id="firstHeading"></a>

volatile是容易變化的意思，表示其值的有效性非常短暫，可能被別的程式或其它因素而遭到修改

**volatile變數不會被最佳化**，或存到暫存器編譯器無法將volatile變數最佳化，降低程式效率volatile變數存在記憶體中，對於經常要存取的值，系統會將其放到暫存器中。  
  
因為多執行緒程式或外部程式隨時有可能修改記憶體中volatile的值，所以不能將其放到暫存器中，避免讀取到錯誤的資料

* 範例：最佳化前，一般程式中若對同一個變數做多次指派，則只有最後一次是有意義的

  ```text
  num = 3;
  num = 0;
  num = 5;
  ```

  最佳化後：

  ```text
  num = 5;
  ```

在嵌入式系統中較常用volatile修飾詞

* 在嵌入式系統中，有些變數可以對應到IC的腳位
* 範例：例如指派PortA=4可以使Led亮一次，假設想讓Led亮三次 寫法為：

  ```text
  PortA=4;
  PortA=4;
  PortA=4;
  ```

* 如果沒將PortA宣告為volatile，則編譯器可能會將程式最佳化為PortA=4; ⇒ Led只亮一次

